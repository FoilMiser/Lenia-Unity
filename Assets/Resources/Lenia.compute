#pragma kernel Step

RWTexture2D<float> _StateIn;
RWTexture2D<float> _StateOut;
Texture2D<float>   _KernelTex;

uint2 _Resolution;
uint  _KernelRadius;
float _Dt;
float _Mu;
float _Sigma;

[numthreads(8,8,1)]
void Step (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _Resolution.x || id.y >= _Resolution.y) return;

    int2 p = int2(id.xy);
    float u = 0.0;
    const int r = (int)_KernelRadius;

    // circular convolution with branchy wrap (avoids modulus warnings/cost)
    [loop] for (int oy = -r; oy <= r; oy++)
    {
        int yy = p.y + oy;
        if (yy < 0) yy += (int)_Resolution.y; else if (yy >= (int)_Resolution.y) yy -= (int)_Resolution.y;

        [loop] for (int ox = -r; ox <= r; ox++)
        {
            int xx = p.x + ox;
            if (xx < 0) xx += (int)_Resolution.x; else if (xx >= (int)_Resolution.x) xx -= (int)_Resolution.x;

            float k = _KernelTex.Load(int3(ox + r, oy + r, 0));
            u += k * _StateIn[int2(xx, yy)];
        }
    }

    // Standard Lenia growth bump
    float g = exp(-0.5 * ((u - _Mu) * (u - _Mu)) / (_Sigma * _Sigma + 1e-8));
    g = g * 2.0 - 1.0;

    float a = _StateIn[p] + _Dt * g;
    _StateOut[p] = saturate(a);
}
